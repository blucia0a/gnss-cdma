/*!
 *  \file avx512_intrinsics.h
 *  \brief      Provides C functions that implement Intel's AVX512 intrinsic
 *  \details    Code style and functionality based in the VOLK project.
 *  \author    Damian Miralles
 *  \author    Jake Johnson
 *  \version   4.1a
 *  \date      Jan 23, 2018
 *  \pre       Make sure you have .bin files containing data and lookup tables.
 *  \note      Functions in the file must target AVX512 enabled platforms.
 */

#include "immintrin.h"
#include <math.h>
#include <stdint.h>
#include <stdio.h>

/*!
 *  \brief Generates a NCO based on the Paralelized Lookup Table (PLUT)
 * approach. \details Implementation uses the SIMD AVX512 intrinsics.
 *  \param[out] sig_nco Sinusoidal wave generated byt the NCO
 *  \param[in] lut Lookup table to be use for the code
 *  \param[in] blk_size Total number of elements in the sig_nco vector
 *  \param[in] rem_carr_phase Carrier phase remainder of the sinusoidal wave
 *  \param[in] carr_freq Carrier frequency of the sinusoidal wave
 *  \param[in] samp_freq Sampling frequency of the signal to be generated
 */
void avx512_nco_si32(int32_t *sig_nco, const int32_t *lut,
                     const int32_t blk_size, const double rem_carr_phase,
                     const double carr_freq, const double samp_freq) {
  int32_t inda;
  const uint32_t sixteenth_points = blk_size / 16;
  const uint32_t nom_carr_step =
      (uint32_t)(carr_freq * (4294967296.0 / samp_freq) + 0.5);

  // Declarations for serial implementation
  uint32_t nom_carr_phase_base =
      (uint32_t)(rem_carr_phase * (4294967296.0 / (2.0 * M_PI)) + 0.5);
  uint32_t nom_carr_idx = 0;

  // Important variable declarations
  __m512i carr_phase_base = _mm512_set1_epi32(nom_carr_phase_base);
  __m512i carr_step_base = _mm512_set_epi32(
      15 * nom_carr_step, 14 * nom_carr_step, 13 * nom_carr_step,
      12 * nom_carr_step, 11 * nom_carr_step, 10 * nom_carr_step,
      9 * nom_carr_step, 8 * nom_carr_step, 7 * nom_carr_step,
      6 * nom_carr_step, 5 * nom_carr_step, 4 * nom_carr_step,
      3 * nom_carr_step, 2 * nom_carr_step, 1 * nom_carr_step,
      0 * nom_carr_step);
  __m512i carr_idx = _mm512_set1_epi32(0);
  __m512i hex_ff = _mm512_set1_epi32(0xFF);
  __m512i nco;
  __m512i carr_step_offset = _mm512_set1_epi32(16 * nom_carr_step);
  __m256i phase_base;

  // First iteration happens outside the loop
  carr_phase_base = _mm512_add_epi32(carr_phase_base, carr_step_base);

  for (inda = 0; inda < sixteenth_points; inda++) {
    // Obtain integer index in 8:24 number
    carr_idx = _mm512_srli_epi32(carr_phase_base, 24);
    carr_idx = _mm512_and_si512(carr_idx, hex_ff);

    // Look in lut
    nco = _mm512_i32gather_epi32(carr_idx, lut, 4);

    // Delta step
    // carr_step_base = _mm256_add_epi32(carr_step_base, carr_step_offset);
    carr_phase_base = _mm512_add_epi32(carr_phase_base, carr_step_offset);

    // 5- Store values in output buffer
    _mm512_storeu_si512((__m512i *)sig_nco, nco);

    // 6- Update pointers
    sig_nco += 16;
  }

  inda = sixteenth_points * 16;
  phase_base = _mm512_extracti32x8_epi32(carr_phase_base, 1);
  nom_carr_phase_base = (uint32_t)_mm256_extract_epi32(phase_base, 7);

  // generate buffer of output
  for (; inda < blk_size; ++inda) {
    // Obtain integer index in 8:24 number
    nom_carr_idx = (nom_carr_phase_base >> 24) & 0xFF;
    // Look in lut
    *sig_nco++ = lut[nom_carr_idx]; // get sample value from lut
    // Delta step
    nom_carr_phase_base += nom_carr_step;
  }
}

/*!
 *  \brief Generates a nominal NCO based on the Direct Lookup Table (DLUT)
 * approach. \param[out] sig_nco Sinusoidal wave generated byt the NCO
 *  \param[in] lut Lookup table to be use for the code
 *  \param[in] blk_size Total number of elements in the sig_nco vector
 *  \param[in] rem_carr_phase Carrier phase remainder of the sinusoidal wave
 *  \param[in] carr_freq Carrier frequency of the sinusoidal wave
 *  \param[in] samp_freq Sampling frequency of the signal to be generated
 */
void avx512_nom_nco_si32(int32_t *sig_nco, const int32_t *lut,
                         const int32_t blk_size, const double rem_carr_phase,
                         const double carr_freq, const double samp_freq) {

  uint32_t carrPhaseBase =
      (rem_carr_phase * (4294967296.0 / (2.0 * M_PI)) + 0.5);
  uint32_t carrStep = (carr_freq * (4294967296.0 / samp_freq) + 0.5);
  uint32_t carrIndex = 0;
  int32_t inda;

  // for each sample
  for (inda = 0; inda < blk_size; ++inda) {
    // Obtain integer index in 8:24 number
    carrIndex = (carrPhaseBase >> 24) & 0xFF;

    // Look in lut
    sig_nco[inda] = lut[carrIndex];

    // Delta step
    carrPhaseBase += carrStep;
  }
}

/*!
 *  \brief Generates an Early, Late and Propmt CA code based on the direct
 * lookup table approach
 * \param[out] ecode Early CA code
 * \param[out] pcode Prompt CA code
 * \param[out] lcode Late CA code
 * \param[in] cacode Nominal satellite ranging code
 * \param[in] blk_size Total number of elements in the sig_nco vector
 * \param[in] rem_code_phase Carrier phase remainder of the sinusoidal wave
 * \param[in] code_freq Carrier frequency of the sinusoidal wave
 * \param[in] samp_freq Sampling frequency of the signal to be generated
 */
void avx512_nom_code_si32(int32_t *ecode, int32_t *pcode, int32_t *lcode,
                          const int32_t *cacode, const int32_t blk_size,
                          const double rem_code_phase, const double code_freq,
                          const double samp_freq) {

  int32_t inda;
  double earlyLateSpc = 0.5;
  double codePhaseStep = code_freq / samp_freq;
  double baseCode;
  int32_t pCodeIdx, eCodeIdx, lCodeIdx;

  // for each sample
  for (inda = 0; inda < blk_size; ++inda) {
    baseCode = (inda * codePhaseStep + rem_code_phase);
    pCodeIdx = (int32_t)(baseCode) < baseCode ? (baseCode + 1) : baseCode;
    eCodeIdx = (int32_t)(baseCode - earlyLateSpc) < (baseCode - earlyLateSpc)
                   ? (baseCode - earlyLateSpc + 1)
                   : (baseCode - earlyLateSpc);
    lCodeIdx = (int32_t)(baseCode + earlyLateSpc) < (baseCode + earlyLateSpc)
                   ? (baseCode + earlyLateSpc + 1)
                   : (baseCode + earlyLateSpc);

    ecode[inda] = *(cacode + eCodeIdx);
    pcode[inda] = *(cacode + pCodeIdx);
    lcode[inda] = *(cacode + lCodeIdx);
  }
}

/*!
 *  \brief Generates an Early, Late and Propmt CA code based on the Parallelized
 * Lookup Table (PLUT) approach.
 *  \param[out] ecode Early CA code
 *  \param[out] pcode Prompt CA code
 *  \param[out] lcode Late CA code
 * \param[in] cacode Nominal satellite ranging code
 *  \param[in] blk_size Total number of elements in the sig_nco vector
 *  \param[in] rem_code_phase Carrier phase remainder of the sinusoidal wave
 *  \param[in] code_freq Carrier frequency of the sinusoidal wave
 *  \param[in] samp_freq Sampling frequency of the signal to be generated
 */
void avx512_code_si32(int32_t *ecode, int32_t *pcode, int32_t *lcode,
                      const int32_t *cacode, const int32_t blk_size,
                      const float rem_code_phase, const float code_freq,
                      const float samp_freq) {

  int32_t inda;
  const uint32_t sixteenth_points = blk_size / 16;
  float earlyLateSpc = 0.5;
  float codePhaseStep = code_freq / samp_freq;
  float baseCode;
  int32_t pCodeIdx, eCodeIdx, lCodeIdx;

  // Important variable declarations
  __m512 ecode_phase_base = _mm512_set1_ps(rem_code_phase - earlyLateSpc + 0.5);
  __m512 pcode_phase_base = _mm512_set1_ps(rem_code_phase + 0.5);
  __m512 lcode_phase_base = _mm512_set1_ps(rem_code_phase + earlyLateSpc + 0.5);

  __m512 code_step_base =
      _mm512_set_ps(15 * codePhaseStep, 14 * codePhaseStep, 12 * codePhaseStep,
                    12 * codePhaseStep, 11 * codePhaseStep, 10 * codePhaseStep,
                    9 * codePhaseStep, 8 * codePhaseStep, 7 * codePhaseStep,
                    6 * codePhaseStep, 5 * codePhaseStep, 4 * codePhaseStep,
                    3 * codePhaseStep, 2 * codePhaseStep, 1 * codePhaseStep,
                    0 * codePhaseStep);
  __m512i ecode_idx = _mm512_set1_epi32(0);
  __m512i pcode_idx = _mm512_set1_epi32(0);
  __m512i lcode_idx = _mm512_set1_epi32(0);

  __m512i elut, plut, llut;
  __m512 code_step_offset = _mm512_set1_ps(16 * codePhaseStep);

  // First iteration happens outside the loop
  ecode_phase_base = _mm512_add_ps(ecode_phase_base, code_step_base);
  pcode_phase_base = _mm512_add_ps(pcode_phase_base, code_step_base);
  lcode_phase_base = _mm512_add_ps(lcode_phase_base, code_step_base);

  for (inda = 0; inda < sixteenth_points; inda++) {
    // Obtain integer index in 8:24 number
    ecode_idx = _mm512_cvtps_epi32(ecode_phase_base);
    pcode_idx = _mm512_cvtps_epi32(pcode_phase_base);
    lcode_idx = _mm512_cvtps_epi32(lcode_phase_base);

    // Look in lut
    elut = _mm512_i32gather_epi32(ecode_idx, cacode, 4);
    plut = _mm512_i32gather_epi32(pcode_idx, cacode, 4);
    llut = _mm512_i32gather_epi32(lcode_idx, cacode, 4);

    // Delta step
    ecode_phase_base = _mm512_add_ps(ecode_phase_base, code_step_offset);
    pcode_phase_base = _mm512_add_ps(pcode_phase_base, code_step_offset);
    lcode_phase_base = _mm512_add_ps(lcode_phase_base, code_step_offset);

    // 5- Store values in output buffer
    _mm512_storeu_si512((__m512i *)ecode, elut);
    _mm512_storeu_si512((__m512i *)pcode, plut);
    _mm512_storeu_si512((__m512i *)lcode, llut);

    // 6- Update pointers
    ecode += 16;
    pcode += 16;
    lcode += 16;
  }

  inda = sixteenth_points * 16;

  // generate buffer of output
  for (; inda < blk_size; ++inda) {
    baseCode = (inda * codePhaseStep + rem_code_phase);
    pCodeIdx = (int32_t)(baseCode) < baseCode ? (baseCode + 1) : baseCode;
    eCodeIdx = (int32_t)(baseCode - earlyLateSpc) < (baseCode - earlyLateSpc)
                   ? (baseCode - earlyLateSpc + 1)
                   : (baseCode - earlyLateSpc);
    lCodeIdx = (int32_t)(baseCode + earlyLateSpc) < (baseCode + earlyLateSpc)
                   ? (baseCode + earlyLateSpc + 1)
                   : (baseCode + earlyLateSpc);

    ecode[inda] = *(cacode + eCodeIdx);
    pcode[inda] = *(cacode + pCodeIdx);
    lcode[inda] = *(cacode + lCodeIdx);
  }
}

/*!
 *  \brief Multiply and accumulates product of two vectors storing the result in
 * an fl32 type
 * \param[in] avector First vector to multiply
 * \param[in] bvector Second vector to multiply
 * \param[in] num_points Number of points in each vector
 */
static inline double avx512_mul_and_acc_si32(const int32_t *avector,
                                             const int32_t *bvector,
                                             uint32_t num_points) {

  int32_t returnValue = 0;
  uint32_t number = 0;
  const uint32_t sixteenth_points = num_points / 16;

  const int32_t *aPtr = avector;
  const int32_t *bPtr = bvector;
  int32_t tempBuffer[16];

  __m512i aVal, bVal, cVal;
  __m512i accumulator = _mm512_setzero_si512();

  for (; number < sixteenth_points; number++) {

    // Load 256-bits of integer data from memory into dst. mem_addr does not
    // need to be aligned on any particular boundary.
    aVal = _mm512_loadu_si512((__m512i *)aPtr);
    bVal = _mm512_loadu_si512((__m512i *)bPtr);

    // TODO: More efficient way to exclude having this intermediate cVal
    // variable??
    cVal = _mm512_mullo_epi32(aVal, bVal);

    // accumulator += _mm256_mullo_epi16(aVal, bVal);
    accumulator = _mm512_add_epi32(accumulator, cVal);

    // Increment pointers
    aPtr += 16;
    bPtr += 16;
  }

  _mm512_storeu_si512((__m512i *)tempBuffer, accumulator);

  returnValue = tempBuffer[0];
  returnValue += tempBuffer[1];
  returnValue += tempBuffer[2];
  returnValue += tempBuffer[3];
  returnValue += tempBuffer[4];
  returnValue += tempBuffer[5];
  returnValue += tempBuffer[6];
  returnValue += tempBuffer[7];
  returnValue += tempBuffer[8];
  returnValue += tempBuffer[9];
  returnValue += tempBuffer[10];
  returnValue += tempBuffer[11];
  returnValue += tempBuffer[12];
  returnValue += tempBuffer[13];
  returnValue += tempBuffer[14];
  returnValue += tempBuffer[15];

  // Perform non SIMD leftover operations
  number = sixteenth_points * 16;
  for (; number < num_points; number++) {
    returnValue += (*aPtr++) * (*bPtr++);
  }
  return returnValue;
}

/*!
 *  \brief Multiply point to point two vectors together as a fl32 type
 * \param[out] cvector Product of point to point multiplication
 * \param[in] avector First vector to multiply
 * \param[in] bvector Second vector to multiply
 * \param[in] num_points Number of points in each
 * vector
 */
static inline void avx512_fl32_x2_mul_si32(int32_t *cvector,
                                           const int32_t *avector,
                                           const int32_t *bvector,
                                           uint32_t num_points) {

  uint32_t number = 0;
  const uint32_t sixteenth_points = num_points / 16;

  int32_t *cPtr = cvector;
  const int32_t *aPtr = avector;
  const int32_t *bPtr = bvector;

  __m512i aVal, bVal, cVal;

  for (; number < sixteenth_points; number++) {

    // Load 256-bits of integer data from memory into dst. mem_addr does not
    // need to be aligned on any particular boundary.
    aVal = _mm512_loadu_si512((__m512i *)aPtr);
    bVal = _mm512_loadu_si512((__m512i *)bPtr);

    // Multiply packed 16-bit integers in a and b, producing intermediate
    // signed 32-bit integers. Truncate each intermediate integer to the 18
    // most significant bits, round by adding 1, and store bits [16:1] to dst.
    cVal = _mm512_mullo_epi32(aVal, bVal);

    // Store 256-bits of integer data from a into memory. mem_addr does
    // not need to be aligned on any particular boundary.
    _mm512_storeu_si512((__m512i *)cPtr, cVal);

    // Increment pointers
    aPtr += 16;
    bPtr += 16;
    cPtr += 16;
  }
}

/*!
 *  \brief Generates a NCO based on the direct lookup table approach with SIMD
 * intrinsic and generates the carrier as fl32 type.
 *  \param[out] sig_nco Sinusoidal wave generated byt the NCO
 *  \param[in] lut Lookup table to be use for the code
 *  \param[in] blk_size Total number of elements in the sig_nco vector
 *  \param[in] rem_carr_phase Carrier phase remainder of the sinusoidal wave
 *  \param[in] carr_freq Carrier frequency of the sinusoidal wave
 *  \param[in] samp_freq Sampling frequency of the signal to be generated
 */
void avx512_nco_fl32(float *sig_nco, const float *lut, const int32_t blk_size,
                     const double rem_carr_phase, const double carr_freq,
                     const double samp_freq) {
  int32_t inda;
  const uint32_t sixteenth_points = blk_size / 16;
  const uint32_t nom_carr_step =
      (uint32_t)(carr_freq * (4294967296.0 / samp_freq) + 0.5);

  // Declarations for serial implementation
  uint32_t nom_carr_phase_base =
      (uint32_t)(rem_carr_phase * (4294967296.0 / (2.0 * M_PI)) + 0.5);
  uint32_t nom_carr_idx = 0;

  // Important variable declarations
  __m512i carr_phase_base = _mm512_set1_epi32(nom_carr_phase_base);
  __m512i carr_step_base = _mm512_set_epi32(
      15 * nom_carr_step, 14 * nom_carr_step, 13 * nom_carr_step,
      12 * nom_carr_step, 11 * nom_carr_step, 10 * nom_carr_step,
      9 * nom_carr_step, 8 * nom_carr_step, 7 * nom_carr_step,
      6 * nom_carr_step, 5 * nom_carr_step, 4 * nom_carr_step,
      3 * nom_carr_step, 2 * nom_carr_step, 1 * nom_carr_step,
      0 * nom_carr_step);
  __m512i carr_idx = _mm512_set1_epi32(0);
  __m512i hex_ff = _mm512_set1_epi32(0xFF);
  __m512 nco;
  __m512i carr_step_offset = _mm512_set1_epi32(16 * nom_carr_step);
  __m256i phase_base;

  // First iteration happens outside the loop
  carr_phase_base = _mm512_add_epi32(carr_phase_base, carr_step_base);

  for (inda = 0; inda < sixteenth_points; inda++) {
    // Obtain integer index in 8:24 number
    carr_idx = _mm512_srli_epi32(carr_phase_base, 24);
    carr_idx = _mm512_and_si512(carr_idx, hex_ff);

    // Look in lut
    nco = _mm512_i32gather_ps(carr_idx, lut, 4);

    // Delta step
    // carr_step_base = _mm256_add_epi32(carr_step_base, carr_step_offset);
    carr_phase_base = _mm512_add_epi32(carr_phase_base, carr_step_offset);

    // 5- Store values in output buffer
    _mm512_storeu_ps((float *)sig_nco, nco);

    // 6- Update pointers
    sig_nco += 16;
  }

  inda = sixteenth_points * 16;
  phase_base = _mm512_extracti32x8_epi32(carr_phase_base, 1);
  nom_carr_phase_base = (uint32_t)_mm256_extract_epi32(phase_base, 7);

  // generate buffer of output
  for (; inda < blk_size; ++inda) {
    // Obtain integer index in 8:24 number
    nom_carr_idx = (nom_carr_phase_base >> 24) & 0xFF;
    // Look in lut
    *sig_nco++ = lut[nom_carr_idx]; // get sample value from lut
    // Delta step
    nom_carr_phase_base += nom_carr_step;
  }
}

/*!
 *  \brief Generates a nominal NCO based on the direct lookup table approach as
 * fl32 type
 *  \param[out] sig_nco Sinusoidal wave generated byt the NCO
 *  \param[in] lut Lookup table to be use for the code
 *  \param[in] blk_size Total number of elements in the sig_nco vector
 *  \param[in] rem_carr_phase Carrier phase remainder of the sinusoidal wave
 *  \param[in] carr_freq Carrier frequency of the sinusoidal wave
 *  \param[in] samp_freq Sampling frequency of the signal to be generated
 */
void avx512_nom_nco_fl32(float *sig_nco, const float *lut,
                         const int32_t blk_size, const double rem_carr_phase,
                         const double carr_freq, const double samp_freq) {

  uint32_t carrPhaseBase =
      (rem_carr_phase * (4294967296.0 / (2.0 * M_PI)) + 0.5);
  uint32_t carrStep = (carr_freq * (4294967296.0 / samp_freq) + 0.5);
  uint32_t carrIndex = 0;
  int32_t inda;

  // for each sample
  for (inda = 0; inda < blk_size; ++inda) {
    // Obtain integer index in 8:24 number
    carrIndex = (carrPhaseBase >> 24) & 0xFF;

    // Look in lut
    sig_nco[inda] = lut[carrIndex];

    // Delta step
    carrPhaseBase += carrStep;
  }
}

/*!
 *  \brief Generates an Early, Late and Propmt CA code based on the direct
 * lookup table approach
 * \param[out] ecode Early CA code
 * \param[out] pcode Prompt CA code
 * \param[out] lcode Late CA code
 * \param[in] cacode Nominal satellite ranging code
 * \param[in] blk_size Total number of elements in the sig_nco vector
 * \param[in] rem_code_phase Carrier phase remainder of the sinusoidal wave
 * \param[in] code_freq Carrier frequency of the sinusoidal wave
 * \param[in] samp_freq Sampling frequency of the signal to be generated
 */
void avx512_nom_code_fl32(float *ecode, float *pcode, float *lcode,
                          const float *cacode, const int32_t blk_size,
                          const double rem_code_phase, const double code_freq,
                          const double samp_freq) {

  int32_t inda;
  double earlyLateSpc = 0.5;
  double codePhaseStep = code_freq / samp_freq;
  double baseCode;
  int32_t pCodeIdx, eCodeIdx, lCodeIdx;

  // for each sample
  for (inda = 0; inda < blk_size; ++inda) {
    baseCode = (inda * codePhaseStep + rem_code_phase);
    pCodeIdx = (float)(baseCode) < baseCode ? (baseCode + 1) : baseCode;
    eCodeIdx = (float)(baseCode - earlyLateSpc) < (baseCode - earlyLateSpc)
                   ? (baseCode - earlyLateSpc + 1)
                   : (baseCode - earlyLateSpc);
    lCodeIdx = (float)(baseCode + earlyLateSpc) < (baseCode + earlyLateSpc)
                   ? (baseCode + earlyLateSpc + 1)
                   : (baseCode + earlyLateSpc);

    ecode[inda] = *(cacode + eCodeIdx);
    pcode[inda] = *(cacode + pCodeIdx);
    lcode[inda] = *(cacode + lCodeIdx);
  }
}

/*!
 *  \brief Generates an Early, Late and Propmt CA code based on the direct
 * lookup table approach with SIMD instructions
 *  \param[out] ecode Early CA code
 *  \param[out] pcode Prompt CA code
 *  \param[out] lcode Late CA code
 *  \param[in] cacode Nominal satellite ranging code
 *  \param[in] blk_size Total number of elements in the sig_nco vector
 *  \param[in] rem_code_phase Carrier phase remainder of the sinusoidal wave
 *  \param[in] code_freq Carrier frequency of the sinusoidal wave
 *  \param[in] samp_freq Sampling frequency of the signal to be generated
 */
void avx512_code_fl32(float *ecode, float *pcode, float *lcode,
                      const float *cacode, const int32_t blk_size,
                      const float rem_code_phase, const float code_freq,
                      const float samp_freq) {

  int32_t inda;
  const uint32_t sixteenth_points = blk_size / 16;
  float earlyLateSpc = 0.5;
  float codePhaseStep = code_freq / samp_freq;
  float baseCode;
  int32_t pCodeIdx, eCodeIdx, lCodeIdx;

  // Important variable declarations
  __m512 ecode_phase_base = _mm512_set1_ps(rem_code_phase - earlyLateSpc + 0.5);
  __m512 pcode_phase_base = _mm512_set1_ps(rem_code_phase + 0.5);
  __m512 lcode_phase_base = _mm512_set1_ps(rem_code_phase + earlyLateSpc + 0.5);

  __m512 code_step_base =
      _mm512_set_ps(15 * codePhaseStep, 14 * codePhaseStep, 12 * codePhaseStep,
                    12 * codePhaseStep, 11 * codePhaseStep, 10 * codePhaseStep,
                    9 * codePhaseStep, 8 * codePhaseStep, 7 * codePhaseStep,
                    6 * codePhaseStep, 5 * codePhaseStep, 4 * codePhaseStep,
                    3 * codePhaseStep, 2 * codePhaseStep, 1 * codePhaseStep,
                    0 * codePhaseStep);
  __m512i ecode_idx = _mm512_set1_epi32(0);
  __m512i pcode_idx = _mm512_set1_epi32(0);
  __m512i lcode_idx = _mm512_set1_epi32(0);

  __m512 elut, plut, llut;
  __m512 code_step_offset = _mm512_set1_ps(16 * codePhaseStep);

  // First iteration happens outside the loop
  ecode_phase_base = _mm512_add_ps(ecode_phase_base, code_step_base);
  pcode_phase_base = _mm512_add_ps(pcode_phase_base, code_step_base);
  lcode_phase_base = _mm512_add_ps(lcode_phase_base, code_step_base);

  for (inda = 0; inda < sixteenth_points; inda++) {
    // Obtain integer index in 8:24 number
    ecode_idx = _mm512_cvtps_epi32(ecode_phase_base);
    pcode_idx = _mm512_cvtps_epi32(pcode_phase_base);
    lcode_idx = _mm512_cvtps_epi32(lcode_phase_base);

    // Look in lut
    elut = _mm512_i32gather_ps(ecode_idx, cacode, 4);
    plut = _mm512_i32gather_ps(pcode_idx, cacode, 4);
    llut = _mm512_i32gather_ps(lcode_idx, cacode, 4);

    // Delta step
    ecode_phase_base = _mm512_add_ps(ecode_phase_base, code_step_offset);
    pcode_phase_base = _mm512_add_ps(pcode_phase_base, code_step_offset);
    lcode_phase_base = _mm512_add_ps(lcode_phase_base, code_step_offset);

    // 5- Store values in output buffer
    _mm512_storeu_ps((float *)ecode, elut);
    _mm512_storeu_ps((float *)pcode, plut);
    _mm512_storeu_ps((float *)lcode, llut);

    // 6- Update pointers
    ecode += 16;
    pcode += 16;
    lcode += 16;
  }

  inda = sixteenth_points * 16;

  // generate buffer of output
  for (; inda < blk_size; ++inda) {
    baseCode = (inda * codePhaseStep + rem_code_phase);
    pCodeIdx = (float)(baseCode) < baseCode ? (baseCode + 1) : baseCode;
    eCodeIdx = (float)(baseCode - earlyLateSpc) < (baseCode - earlyLateSpc)
                   ? (baseCode - earlyLateSpc + 1)
                   : (baseCode - earlyLateSpc);
    lCodeIdx = (float)(baseCode + earlyLateSpc) < (baseCode + earlyLateSpc)
                   ? (baseCode + earlyLateSpc + 1)
                   : (baseCode + earlyLateSpc);

    ecode[inda] = *(cacode + eCodeIdx);
    pcode[inda] = *(cacode + pCodeIdx);
    lcode[inda] = *(cacode + lCodeIdx);
  }
}

/*!
 *  \brief Multiply and accumulates product of two vectors storing the result in
 * an fl32 type
 * \param[in] avector First vector to multiply
 * \param[in] bvector Second vector to multiply
 * \param[in] num_points Number of points in each vector
 * \ return  accumulation result as a fl32 type
 */
static inline float avx512_mul_and_acc_fl32(const float *avector,
                                            const float *bvector,
                                            uint32_t num_points) {

  float returnValue = 0;
  uint32_t number = 0;
  const uint32_t sixteenth_points = num_points / 16;

  const float *aPtr = avector;
  const float *bPtr = bvector;
  float tempBuffer[16];

  __m512 aVal, bVal, cVal;
  __m512 accumulator = _mm512_setzero_ps();

  for (; number < sixteenth_points; number++) {

    // Load 256-bits of integer data from memory into dst. mem_addr does not
    // need to be aligned on any particular boundary.
    aVal = _mm512_loadu_ps((float *)aPtr);
    bVal = _mm512_loadu_ps((float *)bPtr);

    // TODO: More efficient way to exclude having this intermediate cVal
    // variable??
    cVal = _mm512_mul_ps(aVal, bVal);

    // accumulator += _mm256_mullo_epi16(aVal, bVal);
    accumulator = _mm512_add_ps(accumulator, cVal);

    // Increment pointers
    aPtr += 16;
    bPtr += 16;
  }

  _mm512_storeu_ps((float *)tempBuffer, accumulator);

  returnValue = tempBuffer[0];
  returnValue += tempBuffer[1];
  returnValue += tempBuffer[2];
  returnValue += tempBuffer[3];
  returnValue += tempBuffer[4];
  returnValue += tempBuffer[5];
  returnValue += tempBuffer[6];
  returnValue += tempBuffer[7];
  returnValue += tempBuffer[8];
  returnValue += tempBuffer[9];
  returnValue += tempBuffer[10];
  returnValue += tempBuffer[11];
  returnValue += tempBuffer[12];
  returnValue += tempBuffer[13];
  returnValue += tempBuffer[14];
  returnValue += tempBuffer[15];

  // Perform non SIMD leftover operations
  number = sixteenth_points * 16;
  for (; number < num_points; number++) {
    returnValue += (*aPtr++) * (*bPtr++);
  }
  return returnValue;
}

/*!
 *  \brief Multiply point to point two vectors together as a fl32 type
 * \param[out] cvector Product of point to point multiplication
 * \param[in] avector First vector to multiply
 * \param[in] bvector Second vector to multiply
 * \param[in] num_points Number of points in each
 * vector
 */
static inline void avx512_fl32_x2_mul_fl32(float *cvector, const float *avector,
                                           const float *bvector,
                                           uint32_t num_points) {

  uint32_t number = 0;
  const uint32_t sixteenth_points = num_points / 16;

  float *cPtr = cvector;
  const float *aPtr = avector;
  const float *bPtr = bvector;

  __m512 aVal, bVal, cVal;

  for (; number < sixteenth_points; number++) {

    // Load 256-bits of integer data from memory into dst. mem_addr does not
    // need to be aligned on any particular boundary.
    aVal = _mm512_loadu_ps((float *)aPtr);
    bVal = _mm512_loadu_ps((float *)bPtr);

    // Multiply packed 16-bit integers in a and b, producing intermediate
    // signed 32-bit integers. Truncate each intermediate integer to the 18
    // most significant bits, round by adding 1, and store bits [16:1] to dst.
    cVal = _mm512_mul_ps(aVal, bVal);

    // Store 256-bits of integer data from a into memory. mem_addr does
    // not need to be aligned on any particular boundary.
    _mm512_storeu_ps((float *)cPtr, cVal);

    // Increment pointers
    aPtr += 16;
    bPtr += 16;
    cPtr += 16;
  }
}

/*!
 * \brief Multiply and accumulate two vectors of 16bit integers (16i)
 * \param[in] avector First vector to multiply
 * \param[in] bvector Second vector to multiply
 * \param[in] num_points Number of points in each
 * \ return  accumulation result as a double
 * vector
 */
static inline double avx512_mul_and_acc_16i(const short *avector,
                                            const short *bvector,
                                            uint32_t num_points) {

  int32_t returnValue = 0;
  uint32_t number = 0;
  const uint32_t thirtysecondthPoints = num_points / 32;

  const short *aPtr = avector;
  const short *bPtr = bvector;
  short tempBuffer[32];

  __m512i aVal, bVal, cVal;
  __m512i accumulator = _mm512_setzero_si512();

  for (; number < thirtysecondthPoints; number++) {

    // Load 512-bits of integer data from memory into dst. mem_addr does not
    // need to be aligned on any particular boundary.
    aVal = _mm512_loadu_si512((__m512i *)aPtr);
    bVal = _mm512_loadu_si512((__m512i *)bPtr);
    // TODO: More efficient way to exclude having this intermediate cVal
    // variable??
    cVal = _mm512_mullo_epi16(aVal, bVal);

    accumulator = _mm512_adds_epi16(accumulator, cVal);

    // Increment pointers
    aPtr += 32;
    bPtr += 32;
  }

  _mm512_storeu_si512((__m512i *)tempBuffer, accumulator);

  returnValue = tempBuffer[0];
  returnValue += tempBuffer[1];
  returnValue += tempBuffer[2];
  returnValue += tempBuffer[3];
  returnValue += tempBuffer[4];
  returnValue += tempBuffer[5];
  returnValue += tempBuffer[6];
  returnValue += tempBuffer[7];
  returnValue += tempBuffer[8];
  returnValue += tempBuffer[9];
  returnValue += tempBuffer[10];
  returnValue += tempBuffer[11];
  returnValue += tempBuffer[12];
  returnValue += tempBuffer[13];
  returnValue += tempBuffer[14];
  returnValue += tempBuffer[15];
  returnValue += tempBuffer[16];
  returnValue += tempBuffer[17];
  returnValue += tempBuffer[18];
  returnValue += tempBuffer[19];
  returnValue += tempBuffer[20];
  returnValue += tempBuffer[21];
  returnValue += tempBuffer[22];
  returnValue += tempBuffer[23];
  returnValue += tempBuffer[24];
  returnValue += tempBuffer[25];
  returnValue += tempBuffer[26];
  returnValue += tempBuffer[27];
  returnValue += tempBuffer[28];
  returnValue += tempBuffer[29];
  returnValue += tempBuffer[30];
  returnValue += tempBuffer[31];

  // Perform non SIMD leftover operations
  number = thirtysecondthPoints * 32;
  for (; number < num_points; number++) {
    returnValue += (*aPtr++) * (*bPtr++);
  }
  return returnValue;
}
